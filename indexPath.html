<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - FBX loader</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: rgb(255, 255, 255);
				color: #fff;
				margin: 0px;
				overflow: hidden;
			}
			#info {
				color: #fff;
				position: absolute;
				top: 10px;
				width: 100%;
				text-align: center;
				z-index: 100;
				display:block;
			}
			#info a {
				color: #046;
				font-weight: bold;
			}
		</style>
	</head>

	<body>

		<script src="./assets/js/three.js"></script>

		<script src="./assets/js/inflate.min.js"></script>
		<script src="./assets/js/FBXLoader.js"></script>

		<script src="./assets/js/OrbitControls.js"></script>

		<script src="./assets/js/Detector.js"></script>
		<script src="./assets/js/stats.min.js"></script>

		<script>

    var renderer, scene, camera;
    var angle = 0;
    var position = 0;

    // direction vector for movement
    var direction = new THREE.Vector3(1, 0, 0);
    var up = new THREE.Vector3(0, 0, 1);
    var axis = new THREE.Vector3();
    // scalar to simulate speed
    var speed = 0.1;

    if ( ! Detector.webgl ) Detector.addGetWebGLMessage();
    var container, stats, controls;
    var camera, scene, renderer, light;
    var clock = new THREE.Clock();
    var mixers = [];
    var position = 0;



    init();
    animate();
    animatePath();

    function init() {
      container = document.createElement( 'div' );
      document.body.appendChild( container );
      camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 2000000 );
      camera.position.set( 100, 200, 300 );
      // camera.position.set(-100, -100, 20); //Path Camera Settings
      // camera.up.set(0, 0, 1);
      controls = new THREE.OrbitControls( camera );
      controls.target.set( 0, 100, 0 );
      controls.update();
      scene = new THREE.Scene();
      scene.background = new THREE.Color( 0xa0a0a0 );
      scene.fog = new THREE.Fog( 0xa0a0a0, 200, 3000 );
      light = new THREE.HemisphereLight( 0xffffff, 0x444444 );
      light.position.set( 0, 200, 0 );
      scene.add( light );
      light = new THREE.DirectionalLight( 0xffffff );
      light.position.set( 0, 200, 100 );
      light.castShadow = true;
      light.shadow.camera.top = 180;
      light.shadow.camera.bottom = -100;
      light.shadow.camera.left = -120;
      light.shadow.camera.right = 120;
      scene.add( light );
      // scene.add( new THREE.CameraHelper( light.shadow.camera ) );
      // ground
      var meshPlane = new THREE.Mesh( new THREE.PlaneBufferGeometry( 6000, 6000 ), new THREE.MeshPhongMaterial( { color: 0x999999, depthWrite: false } ) );
      meshPlane.rotation.x = - Math.PI / 2;
      meshPlane.receiveShadow = true;
      scene.add( meshPlane );
      var grid = new THREE.GridHelper( 6000, 60, 0x000000, 0x000000 );
      grid.material.opacity = 0.2;
      grid.material.transparent = true;
      scene.add( grid );

      // model
      var loader = new THREE.FBXLoader();
      loader.load( 'assets/models/fbx/Idle.fbx', function ( object ) {
      // loader.load( 'assets/models/fbx/86.fbx', function ( object ) {

        object.mixer = new THREE.AnimationMixer( object );
        mixers.push( object.mixer );
        var action = object.mixer.clipAction( object.animations[ 0 ] );
        action.play();
        object.traverse( function ( child ) {
          if ( child.isMesh ) {
            child.castShadow = true;
            child.receiveShadow = true;
          }
        } );
        scene.add( object );
      } );

      renderer = new THREE.WebGLRenderer( { antialias: true } );
      renderer.setPixelRatio( window.devicePixelRatio );
      renderer.setSize( window.innerWidth, window.innerHeight );
      renderer.shadowMap.enabled = true;
      container.appendChild( renderer.domElement );
      window.addEventListener( 'resize', onWindowResize, false );
      // stats
      stats = new Stats();
      container.appendChild( stats.dom );
    }
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize( window.innerWidth, window.innerHeight );
    }
    //
    function animate() {
      requestAnimationFrame( animate );
      if ( mixers.length > 0 ) {
        for ( var i = 0; i < mixers.length; i ++ ) {
          mixers[ i ].update( clock.getDelta() );
        }
      }
      renderer.render( scene, camera );
      stats.update();
    }

    function animatePath() {
    move();
    requestAnimationFrame(animate);
    render();
    }

    //********************************************************************

                  // three.js info box follows shape
                  // var renderer, scene, camera;
                  // var angle = 0;
                  // var position = 0;

                  // // direction vector for movement
                  // var direction = new THREE.Vector3(1, 0, 0);
                  // var up = new THREE.Vector3(0, 0, 1);
                  // var axis = new THREE.Vector3();
                  // // scalar to simulate speed
                  // var speed = 0.1;


                  // init();
                  // animate();

                  // function init() {

                  // // renderer
                  // renderer = new THREE.WebGLRenderer({
                  //   antialias: true
                  // });
                  // renderer.setPixelRatio(window.devicePixelRatio);
                  // renderer.setSize(window.innerWidth, window.innerHeight);
                  // document.body.appendChild(renderer.domElement);

                  // // scene
                  // scene = new THREE.Scene();

                  // // ambient light
                  // var ambient = new THREE.AmbientLight(0x404040);
                  // scene.add(ambient);

                  // // directional light
                  // var directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
                  // directionalLight.position.set(-1, -1, 1);
                  // scene.add(directionalLight);

                  // // camera
                  // camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 10000);
                  // camera.position.set(-100, -100, 20);
                  // camera.up.set(0, 0, 1);

                  // // controls
                  // controls = new THREE.OrbitControls(camera);
                  // controls.target = new THREE.Vector3(25, -25, 0);
                  // controls.update();

    // material
    var material = new THREE.MeshPhongMaterial({
      color: 0xff0000,
      shading: THREE.FlatShading
    });

    // geometry
    var geometry = new THREE.BoxGeometry(10, 10, 10);

    // mesh
    var mesh = new THREE.Mesh(geometry, material);
    scene.add(mesh);
      
    // the path
    var path = new THREE.Path([
      new THREE.Vector2(-50, -50),
      new THREE.Vector2(0, -50)
    ]);
    var arcRadius = 50;
    path.moveTo(0, 0 - arcRadius);
    path.absarc(0, 0, arcRadius, -Math.PI / 2, 0, false);
    path.lineTo(50, 50);

    drawPath();
      
    // Start angle and point
    previousAngle = getAngle( position );
    previousPoint = path.getPointAt( position );

    

    function drawPath() {
      var vertices = path.getSpacedPoints(20);

      // Change 2D points to 3D points
      for (var i = 0; i < vertices.length; i++) {
        point = vertices[i]
        vertices[i] = new THREE.Vector3(point.x, point.y, 0);
      }
      var lineGeometry = new THREE.Geometry();
      lineGeometry.vertices = vertices;
      var lineMaterial = new THREE.LineBasicMaterial({
        color: 0xffffff
      });
      var line = new THREE.Line(lineGeometry, lineMaterial)
      scene.add(line);
    }


    function move() {
      
      // add up to position for movement
      position += 0.001;

      // get the point at position
      var point = path.getPointAt(position);
      mesh.position.x = point.x;
      mesh.position.y = point.y;

      var angle = getAngle(position);
      // set the quaternion
      mesh.quaternion.setFromAxisAngle( up, angle );
      
      mesh2.position.x += ( point.x - previousPoint.x );
      mesh2.position.y += ( point.y - previousPoint.y );
        
      // set the quaternion
      mesh2.rotation.z += ( angle - previousAngle );
        
      previousPoint = point;
      previousAngle = angle;
        
    }

    function getAngle( position ){
    // get the 2Dtangent to the curve
      var tangent = path.getTangent(position).normalize();

      // change tangent to 3D
      angle = - Math.atan( tangent.x / tangent.y);
      
      return angle;
    }

    // // render
    // function render() {
    //   renderer.render(scene, camera);
    // }

    // // animate
    // function animate() {
    //   move();
    //   requestAnimationFrame(animate);
    //   render();
    // }

		</script>

	</body>
</html>